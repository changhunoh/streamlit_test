# -*- coding: utf-8 -*-
"""langgraph_backend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fiAiZ7tXzk2gbB2iCUju9edOt6WyVVVF
"""

# -*- coding: utf-8 -*-
"""langgraph_backend.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W5sG-zlySfXcL71MuieSm_6SaUOs-mH3
"""

# langgraph_backend.py
import streamlit as st
import sys
import json
from typing import TypedDict, List, Dict, Any

import pandas as pd
import yfinance as yf
import FinanceDataReader as fdr
import google.generativeai as genai
# Google Colab의 userdata 대신 환경 변수 또는 Streamlit secrets를 사용합니다.
# from google.colab import userdata, drive
import os # os 모듈 임포트

from serpapi import GoogleSearch, NaverSearch
from langgraph.graph import StateGraph, START, END # LangGraph 임포트

# --- API Key 설정 (Streamlit 환경에 맞게 변경) ---
GOOGLE_API_KEY = st.secrets.get("GOOGLE_API_KEY")
SERPAPI_API_KEY = st.secrets.get("SERPAPI_API_KEY")

if not GOOGLE_API_KEY:
    print("Warning: GOOGLE_API_KEY 환경 변수가 설정되지 않았습니다.")
if not SERPAPI_API_KEY:
    print("Warning: SERPAPI_API_KEY 환경 변수가 설정되지 않았습니다.")


# PM_Tool_Kit_2025.py 파일이 있는 경로를 sys.path에 추가
# 이 경로는 langgraph_backend.py 파일이 실행되는 환경에 맞춰야 합니다.
# app.py와 langgraph_backend.py가 같은 폴더에 있고, PM_Tool_Kit_2025.py도 같은 폴더에 있다면:
current_dir = os.path.dirname(os.path.abspath(__file__))
pm_tool_kit_path = current_dir # 현재 디렉토리를 PM_Tool_Kit_2025.py의 경로로 가정
if pm_tool_kit_path not in sys.path:
    sys.path.append(pm_tool_kit_path)
    print(f"'{pm_tool_kit_path}' 경로를 sys.path에 추가했습니다.")

# PM_Tool_Kit_2025 임포트
try:
    import PM_Tool_Kit_2025 as pm
    print("PM_Tool_Kit_2025 모듈 임포트 완료.")
except ImportError as e:
    print(f"Error: PM_Tool_Kit_2025 모듈을 임포트할 수 없습니다: {e}")
    print("PM_Tool_Kit_2025.py 파일이 langgraph_backend.py와 같은 폴더에 있는지 확인해주세요.")
    # 실제 앱에서는 sys.exit(1) 대신 오류를 사용자에게 보여주는 방식으로 처리
    pm = None # pm이 없으면 관련 함수는 작동하지 않음

# 1. 상태 정의
class StockRecommendationState(TypedDict):
    messages: List[str]
    query: str
    recommendations: List[Dict[str, Any]]
    feedback: str
    iteration_count: int
    formatted_output: str
    news: Dict[str, List[dict]] # 각 티커별 뉴스를 저장하기 위한 Dict
    judge_score: float
    judge_reason: str
    all_available_stocks_df: pd.DataFrame # FinanceDataReader로 가져온 전체 DataFrame
    filtered_nasdaq_stocks_df: pd.DataFrame # 성능 개선을 위해 필터링된 DataFrame
    # 새로운 필드 추가: Verifier가 Generator에게 전달할 피드백
    judge_feedback_to_generator: str

# 2. Gemini 초기화
try:
    genai.configure(api_key=GOOGLE_API_KEY)
    gemini = genai.GenerativeModel("gemini-1.5-flash")
    print("Gemini 모델 초기화 완료.")
except Exception as e:
    print(f"Error: Gemini 모델 초기화 실패. GOOGLE_API_KEY 확인 필요: {e}")
    gemini = None # 모델 없으면 관련 함수는 작동하지 않음

def call_gemini(prompt: str, temperature: float = 0.7) -> str:
    if gemini is None:
        return json.dumps({"error": "Gemini 모델이 초기화되지 않았습니다."}, ensure_ascii=False)
    generation_config = {
        "temperature": temperature,
    }
    try:
        response = gemini.generate_content(
            prompt,
            generation_config=generation_config,
        )
        return response.text.strip()
    except Exception as e:
        print(f"Error calling Gemini API: {e}")
        return json.dumps({"error": f"Gemini API 호출 오류: {e}"}, ensure_ascii=False)

# FinanceDataReader로 나스닥 주식 리스트 가져오기 (초기 1회만 실행)
try:
    print("FinanceDataReader로 나스닥 주식 리스트 로드 중...")
    nasdaq_stocks_df = fdr.StockListing('NASDAQ')
    nasdaq_stocks_df = nasdaq_stocks_df.drop('IndustryCode', axis=1, errors='ignore')
    print(f"FinanceDataReader로 나스닥 주식 {len(nasdaq_stocks_df)}개 로드 완료.")
except Exception as e:
    print(f"Error: FinanceDataReader로 나스닥 주식 로드 중 오류 발생: {e}. 기본 티커를 사용합니다.")
    nasdaq_stocks_df = pd.DataFrame({
        'Symbol': ["AAPL", "MSFT", "GOOGL", "NVDA", "XOM", "CVX", "PFE", "JNJ"],
        'Name': ["Apple Inc", "Microsoft Corp", "Alphabet Inc", "NVIDIA Corp", "Exxon Mobil Corp", "Chevron Corp", "Pfizer Inc.", "Johnson & Johnson"],
        'Industry': ["전자장비와기기", "소프트웨어", "인터넷서비스", "반도체", "에너지", "에너지", "제약", "제약"]
    })

# 새로운 노드: 관련성 높은 소수의 종목만 선별 (최대 20개)
def select_relevant_stocks(state: StockRecommendationState):
    print("\n--- 사용자 쿼리에 기반한 관련 종목 선별 중 (최대 20개) ---")
    all_stocks_df = state['all_available_stocks_df']
    query = state['query'].lower()

    selected_df = all_stocks_df.copy()

    # 산업 키워드 매핑 (FinanceDataReader의 실제 'Industry' 값에 맞춰 조정 필요)
    tech_keywords = ["소프트웨어", "반도체", "인터넷서비스", "전자장비와기기", "컴퓨터서비스", "통신장비", "기술", "tech", "technology"]
    energy_keywords = ["에너지", "석유와가스", "채굴", "석유화학"]
    healthcare_keywords = ["제약", "생명공학", "헬스케어서비스", "의료장비와서비스"]

    initial_filter_applied = False

    # 1. 사용자 쿼리에 특정 회사명/심볼이 언급되었는지 확인
    specific_companies_symbols = []
    for _, row in all_stocks_df.iterrows():
        company_name_lower = str(row['Name']).lower() # NaN 방지
        symbol_lower = str(row['Symbol']).lower() # NaN 방지
        if (company_name_lower in query and len(company_name_lower) > 2) or \
           (symbol_lower in query and len(symbol_lower) > 1):
            specific_companies_symbols.append(row['Symbol'])
            initial_filter_applied = True

    if specific_companies_symbols:
        selected_df = all_stocks_df[all_stocks_df['Symbol'].isin(specific_companies_symbols)]
        print(f"쿼리에서 특정 회사({', '.join(specific_companies_symbols)})를 감지하여 해당 종목만 선별합니다.")
    else:
        # 2. 특정 회사가 언급되지 않았다면, 산업 필터링 적용
        if any(k in query for k in tech_keywords):
            selected_df = selected_df[selected_df['Industry'].astype(str).str.contains('|'.join(tech_keywords), case=False, na=False)]
            initial_filter_applied = True
            print(f"쿼리에서 기술주 관련 키워드를 감지하여 해당 산업 종목을 선별합니다.")
        elif any(k in query for k in energy_keywords):
            selected_df = selected_df[selected_df['Industry'].astype(str).str.contains('|'.join(energy_keywords), case=False, na=False)]
            initial_filter_applied = True
            print(f"쿼리에서 에너지 관련 키워드를 감지하여 해당 산업 종목을 선별합니다.")
        elif any(k in query for k in healthcare_keywords):
            selected_df = selected_df[selected_df['Industry'].astype(str).str.contains('|'.join(healthcare_keywords), case=False, na=False)]
            initial_filter_applied = True
            print(f"쿼리에서 헬스케어 관련 키워드를 감지하여 해당 산업 종목을 선별합니다.")

    MAX_CANDIDATES = 20 # 최대 20개 후보

    # 3. 최종적으로 최대 20개로 제한
    if len(selected_df) > MAX_CANDIDATES:
        selected_df = selected_df[:MAX_CANDIDATES]
        print(f"선별된 종목이 {MAX_CANDIDATES}개를 초과하여 무작위로 {MAX_CANDIDATES}개만 선택합니다.")
    elif not initial_filter_applied and len(selected_df) > MAX_CANDIDATES:
        selected_df = selected_df.sample(n=MAX_CANDIDATES, random_state=42)
        print(f"쿼리에 특정 산업/기업 키워드가 없어 전체 종목 중 임의의 {MAX_CANDIDATES}개 종목을 선별합니다.")
    elif not initial_filter_applied and len(selected_df) <= MAX_CANDIDATES:
        print(f"쿼리에 특정 산업/기업 키워드가 없어 전체 종목({len(selected_df)}개)을 모두 선별합니다. (20개 이하)")

    # 만약 필터링 후에도 선택된 종목이 0개라면 (매우 드물지만)
    if selected_df.empty:
        print("Warning: 사용자 쿼리에 맞는 종목을 찾지 못했습니다. Yahoo Finance에 있는 기본 기술주 몇 개로 대체합니다.")
        selected_df = pd.DataFrame({
            'Symbol': ["AAPL", "MSFT", "GOOGL"],
            'Name': ["Apple Inc", "Microsoft Corp", "Alphabet Inc"],
            'Industry': ["전자장비와기기", "소프트웨어", "인터넷서비스"]
        })

    print(f"최종 선별된 종목 수: {len(selected_df)}개.")

    state['filtered_nasdaq_stocks_df'] = selected_df
    return state


# 3. 도구: 주식 정보 가져오기 (FinanceDataReader 데이터 사용)
def get_stock_data(state: StockRecommendationState) -> str:
    print("\n--- 주식 데이터 가져오기 및 샤프/MDD 계산 중 ---")
    target_tickers_df = state['filtered_nasdaq_stocks_df']

    all_results = []

    num_tickers_to_process = len(target_tickers_df)
    print(f"선별된 총 {num_tickers_to_process}개 종목에 대해 데이터 처리 시작.")

    # 함수 전체를 try-except로 감싸서 예외 발생 시 빈 JSON 반환 보장
    try:
        for i, row in target_tickers_df.iterrows():
            ticker = row['Symbol']
            print(f"({i+1}/{num_tickers_to_process}) '{ticker}' 데이터 가져오는 중...")

            try:
                stock = yf.Ticker(ticker)
                info = stock.info
                market_cap = info.get("marketCap", 0)
                if market_cap is None:
                    market_cap = 0

                hist_data = stock.history(period="3y") # 최근 3년 데이터

                # 모든 null 값을 가진 행을 드롭 (Adj Close 또는 Close 사용)
                hist_data_cleaned = pd.DataFrame()
                price_column = None
                if 'Adj Close' in hist_data.columns:
                    hist_data_cleaned = hist_data[['Adj Close']].dropna()
                    price_column = 'Adj Close'
                elif 'Close' in hist_data.columns:
                    hist_data_cleaned = hist_data[['Close']].dropna()
                    price_column = 'Close'

                if hist_data_cleaned.empty or len(hist_data_cleaned) < 2: # 최소 2개 데이터 포인트 필요
                    print(f"Warning: '{ticker}'의 3년 주가 데이터에 null 값이 많거나 충분한 데이터가 없어 Sharpe/MDD 계산을 건너뜁니다.")
                    continue

                sharpe_ratio = 0.0
                mdd_value = 0.0

                if price_column and pm: # pm 모듈이 성공적으로 임포트되었는지 확인
                    price_data_for_pm = pd.DataFrame(hist_data_cleaned[price_column]).rename(columns={price_column: ticker})
                    stats = pm.fs_desc(price_data_for_pm, freq='D', rf=0.02)

                    if 'Sharpe' in stats.index and ticker in stats.columns:
                        sharpe_ratio = stats.loc['Sharpe', ticker]
                    if 'MDD' in stats.index and ticker in stats.columns:
                        mdd_value = stats.loc['MDD', ticker]
                elif not pm:
                    print(f"Warning: PM_Tool_Kit_2025 모듈이 로드되지 않아 Sharpe/MDD를 계산할 수 없습니다.")

                # FinanceDataReader에서 가져온 Name과 Industry 정보 활용
                stock_name = row.get('Name', info.get('longName', ticker))
                stock_industry = row.get('Industry', info.get('sector', 'N/A'))


                all_results.append({
                    "ticker": ticker,
                    "name": stock_name,
                    "price": info.get("regularMarketPrice", 0),
                    "sector": stock_industry,
                    "marketCap": market_cap,
                    "sharpeRatio": sharpe_ratio,
                    "mdd": mdd_value
                })
            except Exception as e:
                print(f"Error fetching data or calculating Sharpe/MDD for '{ticker}': {e}. 이 종목은 건너뜁니다.")
                continue

        print(f"최종적으로 {len(all_results)}개 종목에 대한 데이터 가져오기 및 계산 완료.")
        return json.dumps(all_results, ensure_ascii=False)

    except Exception as e:
        print(f"Critical Error in get_stock_data function: {e}. Returning empty JSON.")
        import traceback
        traceback.print_exc()
        return json.dumps([], ensure_ascii=False)

# 4. SerpApi로 뉴스 기사 가져오기
def get_serpapi_news(query: str, num_articles: int = 3, language: str = 'ko', country: str = 'kr', news_engine: str = 'google_news') -> str:
    if not SERPAPI_API_KEY:
        print("SERPAPI_API_KEY가 설정되지 않았습니다.")
        return json.dumps({"error": "SERPAPI_API_KEY가 필요합니다."}, ensure_ascii=False)

    params = {
        "q": query,
        "api_key": SERPAPI_API_KEY,
        "num": num_articles,
    }

    if news_engine == 'google_news':
        params["engine"] = "google_news"
        params["hl"] = language
        params["gl"] = country
        search = GoogleSearch(params)
    elif news_engine == 'naver_news':
        params["engine"] = "naver"
        params["where"] = "news"
        search = NaverSearch(params)
    else:
        return json.dumps({"error": "지원하지 않는 뉴스 엔진입니다."}, ensure_ascii=False)

    try:
        results = search.get_dict()

        if 'error' in results:
            print(f"SerpApi API Error: {results['error']}")
            return json.dumps({"error": results['error']}, ensure_ascii=False)

        articles = []
        if news_engine == 'google_news' and 'news_results' in results:
            for article in results['news_results']:
                articles.append({
                    "title": article.get('title', 'N/A'),
                    "link": article.get('link', 'N/A'),
                    "source": article.get('source', 'N/A'),
                    "publishedAt": article.get('date', 'N/A'),
                    "snippet": article.get('snippet', 'N/A')
                })
        elif news_engine == 'naver_news' and 'news_results' in results:
             for article in results['news_results']:
                articles.append({
                    "title": article.get('title', 'N/A'),
                    "link": article.get('link', 'N/A'),
                    "source": article.get('news_info', {}).get('press_name', 'N/A'),
                    "publishedAt": article.get('news_info', {}).get('news_date', 'N/A'),
                    "snippet": article.get('snippet', 'N/A')
                })
        return json.dumps(articles, ensure_ascii=False, indent=2)

    except Exception as e:
        print(f"SerpApi 뉴스 호출 중 예외 발생: {e}")
        return json.dumps({"error": str(e)}, ensure_ascii=False)

# 8. SerpApi로 뉴스 가져오기 (LLM이 추천한 종목 기반)
def fetch_serpapi_news(state: StockRecommendationState):
    print("\n--- 추천된 종목에 대한 SerpApi 뉴스 데이터 가져오는 중 ---")

    recommended_stocks = state["recommendations"]
    all_ticker_news = {}

    tickers_to_search = recommended_stocks[:3] # 최대 3개 종목까지만 뉴스 검색

    if not tickers_to_search:
        print("추천된 종목이 없거나, 유효한 종목이 없어 뉴스를 검색할 수 없습니다.")
        state["news"] = {}
        return state

    for stock in tickers_to_search:
        ticker = stock.get("ticker")
        name = stock.get("name")

        if not ticker or not name:
            print(f"Warning: 유효한 티커 또는 이름이 없는 종목을 건너뜁니다: {stock}")
            continue

        news_query_company = name
        print(f"'{name}' ({ticker})에 대한 뉴스 검색 중...")
        news_data_str = get_serpapi_news(news_query_company, num_articles=3, language='ko', country='kr', news_engine='google_news')

        try:
            news_list = json.loads(news_data_str)
            if "error" in news_list:
                print(f"뉴스 API 오류 for {name} ({ticker}): {news_list['error']}")
                all_ticker_news[ticker] = []
            else:
                all_ticker_news[ticker] = news_list
                print(f"'{name}' ({ticker})에 대한 뉴스 {len(news_list)}개 로드 완료.")
        except json.JSONDecodeError:
            print(f"SerpApi 뉴스 데이터 JSON 디코딩 오류 for {name} ({ticker}).")
            all_ticker_news[ticker] = []

    state["news"] = all_ticker_news
    return state


# 5. Gemini용 프롬프트 구성
def build_prompt(state: StockRecommendationState) -> str:
    print("\n--- 프롬프트 구성 중 ---")
    stock_info_json = get_stock_data(state)

    if stock_info_json is None:
        print("WARNING: get_stock_data returned None. Treating as empty JSON.")
        stocks = []
    else:
        try:
            stocks = json.loads(stock_info_json)
        except json.JSONDecodeError as e:
            print(f"ERROR: Stock info JSON decoding failed in build_prompt for: {stock_info_json[:200]}... Error: {e}")
            stocks = []

    min_market_cap = 0
    max_market_cap = float('inf')

    if "시가총액" in state['query']:
        try:
            if "이상" in state['query']:
                val_str = state['query'].split("시가총액")[-1].split("이상")[0].strip()
                if "조원" in val_str:
                    min_market_cap = float(val_str.replace("조원", "").strip()) * 1_000_000_000_000
                elif "억원" in val_str:
                    min_market_cap = float(val_str.replace("억원", "").strip()) * 100_000_000
            if "이하" in state['query']:
                val_str = state['query'].split("시가총액")[-1].split("이하")[0].strip()
                if "조원" in val_str:
                    max_market_cap = float(val_str.replace("조원", "").strip()) * 1_000_000_000_000
                elif "억원" in val_str:
                    max_market_cap = float(val_str.replace("억원", "").strip()) * 100_000_000
        except ValueError:
            print("시가총액 파싱 오류: 유효한 숫자가 아닙니다.")
            pass
        print(f"DEBUG: 사용자 쿼리의 시가총액 조건: {min_market_cap:,.0f} ~ {max_market_cap:,.0f}")

    filtered_stock_info_for_prompt = []
    for stock in stocks:
        stock_ticker = stock.get('ticker')
        if stock_ticker and stock_ticker in state['news']:
            stock['news_articles'] = state['news'][stock_ticker]
        else:
            stock['news_articles'] = []

        filtered_stock_info_for_prompt.append(stock)


    filtered_stock_info_str = json.dumps(filtered_stock_info_for_prompt, ensure_ascii=False)

    news_context_per_stock = ""
    for stock_data in filtered_stock_info_for_prompt:
        ticker = stock_data.get('ticker', 'N/A')
        name = stock_data.get('name', 'N/A')
        news_articles = stock_data.get('news_articles', [])

        if news_articles:
            news_context_per_stock += f"\n\n--- '{name}' ({ticker}) 관련 최신 뉴스:\n"
            for i, article in enumerate(news_articles):
                news_context_per_stock += f"- {article.get('title', '제목 없음')} (출처: {article.get('source', 'N/A')}, 발행일: {article.get('publishedAt', 'N/A')})\n"
                news_context_per_stock += f"  링크: {article.get('link', 'N/A')}\n"
                news_context_per_stock += f"  요약: {article.get('snippet', 'N/A')}\n"
        else:
            news_context_per_stock += f"\n\n--- '{name}' ({ticker}) 관련 뉴스 없음\n"

    # Verifier로부터의 피드백을 프롬프트에 추가
    generator_feedback = state.get("judge_feedback_to_generator", "")
    if generator_feedback:
        generator_feedback_str = f"\n\n--- 이전 추천에 대한 평가 피드백 ---\n{generator_feedback}\n이 피드백을 바탕으로 추천을 개선하세요."
    else:
        generator_feedback_str = ""


    return f"""
사용자 요청: {state['query']}
관련 주가 정보 (선별된 종목):
{filtered_stock_info_str}
{news_context_per_stock}
{generator_feedback_str}

위 정보를 참고하여 한국 투자자에게 적절한 주식 종목을 추천해 주세요.
각 추천 종목에 대해 제공된 뉴스 내용을 기반으로 'news_impact' 필드를 추가하고, 뉴스가 해당 종목에 긍정적, 부정적, 중립적 중 어떤 영향을 미칠지 한 문장으로 요약해주세요.
JSON 형식의 리스트로 결과를 출력하세요. 각 종목은 'ticker', 'name', 'price', 'sector', 'marketCap', 'news_impact' (뉴스 영향 요약), 'sharpeRatio', 'mdd' 키를 포함해야 합니다.
'sharpeRatio'는 샤프 비율로 위험 대비 수익률을 의미하며, 높을수록 좋습니다.
'mdd'는 최대 낙폭으로, 과거 최대 손실 폭을 의미하며, 낮을수록(덜 마이너스일수록) 좋습니다.
"""

# 6. 쿼리 처리 노드
def process_query(state: StockRecommendationState):
    print("\n--- 쿼리 처리 중: LLM이 추천 생성 ---")
    prompt = build_prompt(state)
    response = call_gemini(prompt, temperature=0.2)

    cleaned_response = response.strip()
    if cleaned_response.startswith("```json"):
        cleaned_response = cleaned_response[len("```json"):].strip()
    if cleaned_response.endswith("```"):
        cleaned_response = cleaned_response[:-len("```")].strip()

    state["messages"].append(cleaned_response)
    print(f"Gemini 원본 응답 (정제 전): {response[:100]}...")
    print(f"정제된 응답: {cleaned_response[:100]}...")
    return state

# 7. 추천 평가 노드
def evaluate_recommendations(state: StockRecommendationState):
    print("\n--- 추천 평가 중: JSON 파싱 및 초기 유효성 검사 ---")
    try:
        parsed = json.loads(state["messages"][-1])
        if not isinstance(parsed, list):
            parsed = [] if not parsed else [parsed]
    except json.JSONDecodeError as e:
        print(f"ERROR: JSON 디코딩 오류 발생: {e}")
        print(f"오류가 발생한 문자열: '{state['messages'][-1][:200]}...'")
        parsed = []
    except Exception as e:
        print(f"ERROR: 파싱 중 일반 오류 발생: {e}")
        parsed = []

    state["recommendations"] = parsed
    state["feedback"] = "JSON 형식 오류" if not parsed and state["messages"][-1] else "초기 평가 완료"
    if not parsed and state["messages"][-1] and "```json" not in state["messages"][-1]:
        state["feedback"] = "응답 형식 오류: 유효한 JSON이 아닙니다."

    print(f"평가 후 recommendations: {state.get('recommendations', '없음')}")
    return state

# 9. LLM Judge Verifier
def llm_judge_verifier(state: StockRecommendationState):
    print("\n--- LLM Judge 검증 중 ---")
    user_query = state["query"]
    llm_recommendations = json.dumps(state["recommendations"], ensure_ascii=False, indent=2)
    news_data_str = json.dumps(state["news"], ensure_ascii=False, indent=2)

    judge_prompt = f"""
당신은 주식 추천 에이전트의 응답을 평가하는 전문가입니다.
다음 기준에 따라 응답을 평가하고, 점수(0.0 ~ 1.0)와 평가 이유를 JSON 형식으로 출력하세요.

--- 평가 기준 ---
1.  **JSON 형식 준수:** 응답이 유효한 JSON 배열 형식인가? (점수 0.0 또는 1.0)
2.  **필수 필드 포함 여부:** 각 추천 종목 객체에 'ticker', 'name', 'price', 'sector', 'marketCap', 'news_impact', 'sharpeRatio', 'mdd' 필드가 모두 포함되어 있는가? (필드 누락 시 감점)
3.  **관련성:** 사용자 쿼리("{user_query}")와 제공된 주식 데이터, 뉴스 데이터에 기반하여 합리적인 추천인가? (점수 0.0 ~ 1.0)
4.  **추천 충분성:** 최소 1개 이상의 종목이 추천되었는가? (추천 없으면 감점)
5.  **위험 조정 수익률 (샤프 비율) 고려:** 제공된 주식 정보에 'sharpeRatio'가 있는 경우, 이 값이 투자 위험 대비 수익률을 잘 나타내는지 고려하여 추천의 질을 평가하세요. **샤프 비율이 높을수록 위험 대비 수익률이 좋음을 의미합니다.** (점수 0.0 ~ 1.0)
  - 1.0 미만 (0.0 ~ 0.99): 위험 대비 수익이 충분하지 않거나, 손실 가능성이 있습니다.0.2점을 부여합니다.
  - 1.0 ~ 1.99: 양호한 수준으로 간주됩니다. 위험 대비 적절한 초과 수익을 제공합니다. 0.5점을 부여합니다.
  - 2.0 ~ 2.99: 매우 좋은 수준입니다. 위험 대비 뛰어난 성과를 보여줍니다. 0.8점을 부여합니다.
  - 3.0 이상: 탁월한 수준으로 간주됩니다. 매우 드물게 나타납니다. 1점을 부여합니다.
6.  **최대 낙폭 (MDD) 고려:** 제공된 주식 정보에 'mdd' 값이 있는 경우, 이 값이 해당 종목의 과거 최대 손실 폭을 나타내는지 고려하여 추천의 질을 평가하세요. **MDD가 낮을수록(즉, 덜 마이너스일수록) 과거 손실 위험이 적었음을 의미합니다.** (점수 0.0 ~ 1.0)
 - 매우 낮은 MDD (0% ~ 5%): 1점
 - 낮은 MDD (5% ~ 10%): 0.8점
 - 적정 MDD (10% ~ 20%): 0.5점
 - 높은 MDD (20% ~ 30%): 0.3점
 - 매우 높은 MDD (30% 이상): 0.1점


--- 제공된 정보 ---
사용자 쿼리: {user_query}
모델 추천 응답 (JSON):
{llm_recommendations}
참고 뉴스 데이터 (각 종목별):
{news_data_str}

--- 출력 형식 ---
{{
  "score": <총점 (0.0 ~ 1.0)>,
  "reason": "<평가 이유 요약>",
  "details": [
    {{"criterion": "JSON 형식 준수", "passed": true/false, "note": "..."}},
    {{"criterion": "필수 필드 포함 여부", "passed": true/false, "missing_fields": ["..."], "note": "..."}},
    {{"criterion": "관련성", "score": 0.0~1.0, "note": "..."}},
    {{"criterion": "뉴스 영향 분석", "score": 0.0~1.0, "note": "..."}},
    {{"criterion": "추천 충분성", "passed": true/false, "note": "..."}},
    {{"criterion": "위험 조정 수익률 (샤프 비율) 고려", "score": 0.0~1.0, "note": "..."}},
    {{"criterion": "최대 낙폭 (MDD) 고려", "score": 0.0~1.0, "note": "..."}}
  ]
}}
"""
    judge_response_raw = call_gemini(judge_prompt, temperature=0.0)

    cleaned_judge_response = judge_response_raw.strip()
    if cleaned_judge_response.startswith("```json"):
        cleaned_judge_response = cleaned_judge_response[len("```json"):].strip()
    if cleaned_judge_response.endswith("```"):
        cleaned_judge_response = cleaned_judge_response[:-len("```")].strip()

    try:
        judge_result = json.loads(cleaned_judge_response)
        score = judge_result.get("score", 0.0)
        reason = judge_result.get("reason", "평가 이유 없음")

        state["judge_score"] = score
        state["judge_reason"] = reason

        # Verifier가 Generator에게 전달할 피드백 로직 추가
        if score >= 0.3: # 좋은 응답 또는 개선 가능성이 있는 응답
            state["feedback"] = "만족" if score >= 0.7 else "개선 필요"
            state["judge_feedback_to_generator"] = f"이전 추천은 만족스러운 결과였습니다. 총점: {score:.2f}. 더 이상 개선할 필요는 없습니다." \
                                                  if score >= 0.7 else \
                                                  f"이전 추천은 개선이 필요합니다. 총점: {score:.2f}. 다음 사항을 고려하여 추천을 수정하세요: {reason}"
        else: # score < 0.3, 나쁜 응답
            state["feedback"] = "나쁜 응답"
            state["judge_feedback_to_generator"] = f"이전 추천은 품질이 낮아 다시 생성해야 합니다. 총점: {score:.2f}. 주요 문제점: {reason}. 데이터를 다시 분석하고 사용자 쿼리에 더 잘 맞는 추천을 제공하세요."


        print(f"LLM Judge 평가 결과: 점수={score:.2f}, 피드백='{state['feedback']}', 이유='{reason}'")

    except json.JSONDecodeError as e:
        print(f"LLM Judge 응답 JSON 디코딩 오류: {e}")
        print(f"오류난 Judge 응답: {cleaned_judge_response}")
        state["feedback"] = "LLM Judge 응답 오류"
        state["judge_score"] = 0.0
        state["judge_reason"] = f"LLM Judge 응답 파싱 실패: {e}"
        state["judge_feedback_to_generator"] = "LLM Judge 응답 파싱 실패로 인해 피드백을 제공할 수 없습니다."
    except Exception as e:
        print(f"LLM Judge 처리 중 일반 오류: {e}")
        state["feedback"] = "LLM Judge 내부 오류"
        state["judge_score"] = 0.0
        state["judge_reason"] = f"LLM Judge 내부 오류: {e}"
        state["judge_feedback_to_generator"] = "LLM Judge 내부 오류로 인해 피드백을 제공할 수 없습니다."

    state["iteration_count"] += 1
    return state

# 10. 추천을 표시용으로 포맷팅
def format_recommendations(state: StockRecommendationState):
    print("\n--- 추천 포맷팅 중 ---")
    recommendations = state["recommendations"]
    if not recommendations:
        state["formatted_output"] = "죄송합니다. 현재 추천할 수 있는 주식 종목이 없습니다."
    else:
        formatted_list = ["**추천 주식 종목:**"]
        for i, rec in enumerate(recommendations):
            ticker = rec.get('ticker', 'N/A')
            name = rec.get('name', 'N/A')
            price = rec.get('price', 'N/A')
            sector = rec.get('sector', 'N/A')
            market_cap = rec.get('marketCap', 0)
            news_impact = rec.get('news_impact', '분석되지 않음')
            sharpe_ratio = rec.get('sharpeRatio', 'N/A')
            mdd_value = rec.get('mdd', 'N/A')

            sharpe_display = f"{sharpe_ratio:.2f}" if isinstance(sharpe_ratio, (int, float)) else sharpe_ratio
            mdd_display = f"{mdd_value:.2%}" if isinstance(mdd_value, (int, float)) else mdd_value

            # 각 종목별 뉴스도 함께 출력하도록 변경
            news_for_this_ticker = state['news'].get(ticker, [])
            news_summary_str = ""
            if news_for_this_ticker:
                news_summary_str += "\n     관련 뉴스:"
                for j, article in enumerate(news_for_this_ticker[:2]): # 각 종목당 최대 2개 뉴스 요약
                    news_summary_str += f"\n     - {article.get('title', '제목 없음')} (출처: {article.get('source', 'N/A')})"

            formatted_list.append(
                f"{i+1}. **{name}** ({ticker})\n"
                f"   - 현재 가격: ${price:,.2f}\n"
                f"   - 섹터: {sector}\n"
                f"   - 시가총액: ${market_cap:,.0f}\n"
                f"   - 뉴스 영향: {news_impact}\n"
                f"   - 샤프 비율 (3y): {sharpe_display}\n"
                f"   - 최대 낙폭 (MDD): {mdd_display}"
                f"{news_summary_str}"
            )
        state["formatted_output"] = "\n".join(formatted_list)

    if "judge_score" in state:
        state["formatted_output"] += f"\n\n--- LLM Judge 평가 결과 ---"
        state["formatted_output"] += f"\n총점: {state['judge_score']:.2f}/1.0"
        state["formatted_output"] += f"\n이유: {state['judge_reason']}"

    print(f"포맷팅된 출력:\n{state['formatted_output']}")
    return state

# 11. 조건부 루프
def should_continue(state: StockRecommendationState) -> str:
    print(f"\n--- 계속 여부 확인 중 ---")
    print(f"현재 피드백: {state['feedback']}, 반복 횟수: {state['iteration_count']}, Judge Score: {state['judge_score']:.2f}")

    # 좋은 응답: Verifier의 점수가 0.3 이상일 때 (최소 1회 추천 후 판단)
    if state["judge_score"] >= 0.3 and state["iteration_count"] >= 1:
        print(f"DEBUG: LLM Judge 점수({state['judge_score']:.2f})가 0.3 이상이므로 워크플로우를 종료합니다.")
        return "end"

    # 나쁜 응답 또는 개선 필요: Verifier의 점수가 0.3 미만이고, 최대 반복 횟수에 도달하지 않았을 때
    if state["iteration_count"] < 3: # 최대 3회 반복 (원하는 반복 횟수로 조절 가능)
        print(f"DEBUG: LLM Judge 점수({state['judge_score']:.2f})가 0.3 미만이거나 반복 횟수 미달이므로 다음 반복을 진행합니다.")
        return "process_query" # 다음 반복 시 LLM에게 추천을 요청하기 위해 process_query로 연결

    # 최대 반복 횟수에 도달했지만 여전히 점수가 0.3 미만인 경우 (최종 종료)
    print(f"DEBUG: 최대 반복 횟수(3회)에 도달했지만 LLM Judge 점수({state['judge_score']:.2f})가 0.3 미만이므로 워크플로우를 종료합니다.")
    return "end"

# 12. LangGraph 구성
from langgraph.graph import StateGraph # StateGraph 임포트 확인

workflow = StateGraph(StockRecommendationState)

# 노드 정의
workflow.add_node("select_relevant_stocks", select_relevant_stocks)
workflow.add_node("process_query", process_query)
workflow.add_node("fetch_serpapi_news", fetch_serpapi_news)
workflow.add_node("evaluate_recommendations", evaluate_recommendations)
workflow.add_node("llm_judge_verifier", llm_judge_verifier)
workflow.add_node("format_recommendations", format_recommendations)

# 엣지 정의
workflow.add_edge(START, "select_relevant_stocks")
workflow.add_edge("select_relevant_stocks", "process_query")
workflow.add_edge("process_query", "evaluate_recommendations")
workflow.add_edge("evaluate_recommendations", "fetch_serpapi_news")
workflow.add_edge("fetch_serpapi_news", "llm_judge_verifier")

# LLM Judge Verifier의 결과에 따라 조건부 엣지 추가
workflow.add_conditional_edges(
    "llm_judge_verifier",
    should_continue,
    {
        "process_query": "process_query", # 점수가 낮으면 Generator로 돌아가 재시도
        "end": "format_recommendations"    # 점수가 높거나 최대 반복이면 최종 포맷팅으로
    }
)

# 최종 결과 포맷팅 노드에서 END로 연결
workflow.add_edge("format_recommendations", END)


graph = workflow.compile()